<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/png" href="./assets/character-walking-0.png" />
  <title>Cova Simulator</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #000;
      font-family: monospace;
      overflow: hidden;
      /* Evitar scroll */
    }

    canvas {
      margin-top: 4vhx;
    }

    #game {
      border: 8px solid #333;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
      max-width: 100vw;
      max-height: 100vh;
      width: auto;
      height: auto;
    }

    /* Estilos espec√≠ficos para dispositivos m√≥viles */
    @media (max-width: 768px) {
      #game {
        border: 4px solid #333;
        /* Borde m√°s delgado en m√≥viles */
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
      }
    }

    @media (max-width: 480px) {
      #game {
        border: 2px solid #333;
        /* Borde a√∫n m√°s delgado en pantallas muy peque√±as */
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
      }
    }
  </style>
</head>

<body>
  <canvas id="game" width="240" height="160"></canvas>

  <audio id="background" src="assets/background.mp3"></audio>
  <audio id="collision" src="assets/collision.mp3"></audio>
  <audio id="drink" src="assets/drink.mp3"></audio>
  <audio id="talk" src="assets/talk.mp3"></audio>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false });

    // Funci√≥n para redimensionar el canvas de forma responsive
    function resizeCanvas() {
      const aspectRatio = 240 / 160; // Ratio original del juego (1.5)
      let canvasWidth, canvasHeight;

      // Calcular el tama√±o m√°ximo manteniendo el aspect ratio
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;

      // Reducir un poco para dejar espacio para bordes y m√°rgenes
      const maxWidth = windowWidth * 0.95;
      const maxHeight = windowHeight * 0.95;

      if (maxWidth / aspectRatio <= maxHeight) {
        // Limitado por el ancho
        canvasWidth = maxWidth;
        canvasHeight = maxWidth / aspectRatio;
      } else {
        // Limitado por la altura
        canvasHeight = maxHeight;
        canvasWidth = maxHeight * aspectRatio;
      }

      // Aplicar el tama√±o calculado
      canvas.style.width = Math.floor(canvasWidth) + 'px';
      canvas.style.height = Math.floor(canvasHeight) + 'px';

      // En dispositivos m√≥viles muy peque√±os, aumentar un poco m√°s el tama√±o
      if (window.innerWidth <= 480 && canvasWidth < 300) {
        canvas.style.width = Math.min(windowWidth * 0.98, 400) + 'px';
        canvas.style.height = Math.min(windowWidth * 0.98 / aspectRatio, 400 / aspectRatio) + 'px';
      }
    }

    // Redimensionar al cargar y cuando cambie el tama√±o de ventana
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Tambi√©n redimensionar cuando cambie la orientaci√≥n del dispositivo
    window.addEventListener('orientationchange', () => {
      setTimeout(resizeCanvas, 100); // Peque√±o delay para que se actualice el tama√±o de ventana
    });

    // Paleta GBA
    const C = {
      bg: '#081820', floor: '#184a48', floor2: '#205850',
      bar: '#502818', bar2: '#683020', skin: '#f8c898',
      hair: '#503020', ui: '#001820', uiBorder: '#20c0d0',
      text: '#f8f8f8', highlight: '#f8d048', red: '#f83030', green: '#30d048'
    };

    const keys = {};
    const WORLD_HEIGHT = 500;
    const touch = {
      joystick: { active: false, dx: 0, dy: 0, id: null },
      button: { pressed: false, id: null },
      // Controles para la fase bonus
      bonusLeft: { pressed: false, id: null },
      bonusRight: { pressed: false, id: null }
    };
    const state = {
      scene: 0,
      px: 120, py: 400, // Jugador empieza abajo
      camY: 320, // C√°mara
      time: 1260,
      drunk: 0,
      score: 0,
      facing: 1,
      anim: 0,
      tick: 0,
      girlCount: 0,
      mustDrink: false,
      mustTalk: false,
      dialog: '',
      dTimer: 0,
      lastTalk: 0,
      inverted: false,
      color: 0,
      spacePressed: false,
      isMoving: false,
      // Variables para transiciones y pantallas intermedias
      fadeAlpha: 0,
      transitioning: false,
      nextScene: null,
      fadeDirection: 'in', // 'in' para fade in, 'out' para fade out
      finalScore: 0,
      // Barra arriba
      barY: 40,
      // Chicas en pista de baile (abajo)
      girls: Array(10).fill(0).map((_, i) => ({
        x: 30 + (i % 5) * 40,
        y: 380 + Math.floor(i / 5) * 30,
        t: 0,
        c: i,
        spriteType: i % 2 // Alterna entre 0 (girl0) y 1 (girl1)
      })),
      // Obst√°culos con cooldown
      obstacles: [
        { x: 20, y: 100, w: 16, h: 16, t: 0 },
        { x: 204, y: 100, w: 16, h: 16, t: 0 },
        { x: 60, y: 150, w: 16, h: 16, t: 0 },
        { x: 164, y: 150, w: 16, h: 16, t: 0 },
        { x: 100, y: 200, w: 16, h: 16, t: 0 },
        { x: 124, y: 200, w: 16, h: 16, t: 0 },
        { x: 40, y: 260, w: 16, h: 16, t: 0 },
        { x: 184, y: 260, w: 16, h: 16, t: 0 }
      ],
      bonus: { x: 120, target: 120, t: 0, score: 0, max: 30 }
    };

    function drawSvg(svgBase64, x, y, w, h) {
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d');
      const img = new Image();
      img.onload = function () {
        ctx.clearRect(x, y, canvas.width, canvas.height);
        ctx.drawImage(img, x, y, w, h);
      };
      img.src = svgBase64;
    }

    const PC = ['#f83030', '#30d048', '#f8d048', '#30a0f8', '#d048f8', '#f89030'];
    const bgMusic = document.getElementById('background');

    // Touch controls
    canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mouseup', handleMouseUp);

    function handleTouchStart(e) {
      e.preventDefault();
      for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        const rect = canvas.getBoundingClientRect();
        const x = (t.clientX - rect.left) * (240 / rect.width);
        const y = (t.clientY - rect.top) * (160 / rect.height);

        // Transiciones de pantalla para men√∫ (escena 0), pantallas intermedias (0.5, 1.5) y pantalla final (escena 3)
        if (state.scene === 0 || state.scene === 0.5 || state.scene === 1.5 || state.scene === 3) {
          handleScreenTransition();
          return;
        }

        if (state.scene === 2) {
          // Controles para la fase bonus
          // Bot√≥n izquierda
          if (x < 50 && y > 110) {
            touch.bonusLeft.pressed = true;
            touch.bonusLeft.id = t.identifier;
          }
          // Bot√≥n derecha
          if (x > 190 && y > 110) {
            touch.bonusRight.pressed = true;
            touch.bonusRight.id = t.identifier;
          }
        } else if (state.scene === 1) {
          // Controles del juego principal
          // Joystick (derecha)
          if (x > 190 && y > 110) {
            touch.joystick.active = true;
            touch.joystick.id = t.identifier;
          }
          // Bot√≥n acci√≥n (izquierda)
          if (x < 50 && y > 110) {
            touch.button.pressed = true;
            touch.button.id = t.identifier;
            state.spacePressed = true;
          }
        }
      }
    }

    function handleTouchMove(e) {
      e.preventDefault();
      for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (touch.joystick.active && t.identifier === touch.joystick.id) {
          const rect = canvas.getBoundingClientRect();
          const x = (t.clientX - rect.left) * (240 / rect.width);
          const y = (t.clientY - rect.top) * (160 / rect.height);
          const dx = x - 215;
          const dy = y - 135;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const maxDist = 15;
          if (dist > maxDist) {
            touch.joystick.dx = (dx / dist) * maxDist;
            touch.joystick.dy = (dy / dist) * maxDist;
          } else {
            touch.joystick.dx = dx;
            touch.joystick.dy = dy;
          }
        }
      }
    }

    function handleTouchEnd(e) {
      e.preventDefault();
      for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];

        // Controles del juego principal
        if (t.identifier === touch.joystick.id) {
          touch.joystick.active = false;
          touch.joystick.dx = 0;
          touch.joystick.dy = 0;
          touch.joystick.id = null;
        }
        if (t.identifier === touch.button.id) {
          touch.button.pressed = false;
          touch.button.id = null;
          state.spacePressed = false;
        }

        // Controles de la fase bonus
        if (t.identifier === touch.bonusLeft.id) {
          touch.bonusLeft.pressed = false;
          touch.bonusLeft.id = null;
        }
        if (t.identifier === touch.bonusRight.id) {
          touch.bonusRight.pressed = false;
          touch.bonusRight.id = null;
        }
      }
    }

    function handleMouseDown(e) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (240 / rect.width);
      const y = (e.clientY - rect.top) * (160 / rect.height);

      // Transiciones de pantalla para men√∫ (escena 0), pantallas intermedias (0.5, 1.5) y pantalla final (escena 3)
      if (state.scene === 0 || state.scene === 0.5 || state.scene === 1.5 || state.scene === 3) {
        handleScreenTransition();
        return;
      }

      if (state.scene === 2) {
        // Controles para la fase bonus
        if (x < 50 && y > 110) {
          touch.bonusLeft.pressed = true;
          touch.bonusLeft.id = 'mouse-left';
        }
        if (x > 190 && y > 110) {
          touch.bonusRight.pressed = true;
          touch.bonusRight.id = 'mouse-right';
        }
      } else if (state.scene === 1) {
        // Controles del juego principal
        if (x > 190 && y > 110) {
          touch.joystick.active = true;
          touch.joystick.id = 'mouse';
        }
        if (x < 50 && y > 110) {
          touch.button.pressed = true;
          state.spacePressed = true;
        }
      }
    }

    function handleMouseMove(e) {
      if (touch.joystick.active && touch.joystick.id === 'mouse') {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (240 / rect.width);
        const y = (e.clientY - rect.top) * (160 / rect.height);
        const dx = x - 215;
        const dy = y - 135;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const maxDist = 15;
        if (dist > maxDist) {
          touch.joystick.dx = (dx / dist) * maxDist;
          touch.joystick.dy = (dy / dist) * maxDist;
        } else {
          touch.joystick.dx = dx;
          touch.joystick.dy = dy;
        }
      }
    }

    function handleMouseUp(e) {
      // Controles del juego principal
      if (touch.joystick.id === 'mouse') {
        touch.joystick.active = false;
        touch.joystick.dx = 0;
        touch.joystick.dy = 0;
        touch.joystick.id = null;
      }
      if (touch.button.pressed) {
        touch.button.pressed = false;
        state.spacePressed = false;
      }

      // Controles de la fase bonus
      if (touch.bonusLeft.id === 'mouse-left') {
        touch.bonusLeft.pressed = false;
        touch.bonusLeft.id = null;
      }
      if (touch.bonusRight.id === 'mouse-right') {
        touch.bonusRight.pressed = false;
        touch.bonusRight.id = null;
      }
    }

    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (state.scene === 0) {
        if (e.key === 'Enter' || e.key === ' ') {
          handleScreenTransition();
        }
        //if (e.key === 'ArrowLeft') state.color = (state.color + 5) % 6;
        //if (e.key === 'ArrowRight') state.color = (state.color + 1) % 6;
      }
      if (state.scene === 0.5 && (e.key === 'Enter' || e.key === ' ')) {
        handleScreenTransition();
      }
      if (state.scene === 1.5 && (e.key === 'Enter' || e.key === ' ')) {
        handleScreenTransition();
      }
      if (state.scene === 3 && (e.key === 'Enter' || e.key === ' ')) {
        handleScreenTransition();
      }
      if (e.key === ' ' && (state.scene === 1 || state.scene === 2)) {
        state.spacePressed = true;
      }
    });

    document.addEventListener('keyup', e => {
      keys[e.key] = false;
      if (e.key === ' ') state.spacePressed = false;
    });

    // Funciones para manejar transiciones fade y pantallas intermedias
    function startFadeOut(nextScene) {
      state.transitioning = true;
      state.fadeDirection = 'out';
      state.nextScene = nextScene;
      state.fadeAlpha = 0;
    }

    function startFadeIn() {
      state.transitioning = true;
      state.fadeDirection = 'in';
      state.fadeAlpha = 1;
    }

    function updateFade(dt) {
      if (!state.transitioning) return;

      const fadeSpeed = 2; // Velocidad del fade

      if (state.fadeDirection === 'out') {
        state.fadeAlpha += fadeSpeed * dt;
        if (state.fadeAlpha >= 1) {
          state.fadeAlpha = 1;
          // Cambiar escena cuando el fade out termine
          if (state.nextScene !== null) {
            changeToScene(state.nextScene);
            state.nextScene = null;
          }
          // Comenzar fade in
          state.fadeDirection = 'in';
        }
      } else if (state.fadeDirection === 'in') {
        state.fadeAlpha -= fadeSpeed * dt;
        if (state.fadeAlpha <= 0) {
          state.fadeAlpha = 0;
          state.transitioning = false;
        }
      }
    }

    function changeToScene(sceneNumber) {
      if (sceneNumber === 0.5) {
        // Pantalla intermedia "comienza la noche"
        state.scene = 0.5;
      } else if (sceneNumber === 1.5) {
        // Pantalla intermedia del bonus
        state.finalScore = state.score;
        state.scene = 1.5;
      } else {
        state.scene = sceneNumber;
        if (sceneNumber === 1) {
          // Resetear estado del juego
          state.px = 120;
          state.py = 400;
          state.camY = 320;
          bgMusic.pause();
          bgMusic.currentTime = 0;
          bgMusic.volume = 1.0;
          document.getElementById('background').play();
        } else if (sceneNumber === 2) {
          // Iniciar bonus
          state.inverted = false;
          state.isMoving = true;
          state.facing = 0;
        } else if (sceneNumber === 0) {
          // Volver al men√∫
          bgMusic.pause();
          bgMusic.currentTime = 0;
          state.score = 0;
          state.bonus.score = 0;
          state.bonus.t = 0;
          state.drunk = 0;
          state.girlCount = 0;
          state.time = 1260;
          state.px = 120;
          state.py = 400;
          state.camY = 320;
          state.mustDrink = false;
          state.mustTalk = false;
          state.isMoving = false;
          state.dialog = '';
          state.dTimer = 0;
          state.girls.forEach(g => g.t = 0);
          state.obstacles.forEach(obs => obs.t = 0);
          state.barmaidTimer = 0;
        }
      }
    }

    function drawFade() {
      if (state.transitioning && state.fadeAlpha > 0) {
        ctx.fillStyle = `rgba(0, 0, 0, ${state.fadeAlpha})`;
        ctx.fillRect(0, 0, 240, 160);
      }
    }

    // Funci√≥n auxiliar para manejar transiciones de pantalla
    function handleScreenTransition() {
      if (state.scene === 0) {
        // Transici√≥n del men√∫ a pantalla intermedia
        startFadeOut(0.5);
      } else if (state.scene === 0.5) {
        // Transici√≥n de pantalla intermedia a juego
        startFadeOut(1);
      } else if (state.scene === 1.5) {
        // Transici√≥n de pantalla intermedia a bonus
        startFadeOut(2);
      } else if (state.scene === 3 && Date.now() - state.time > 1500) {
        // Transici√≥n de la pantalla final al men√∫
        startFadeOut(0);
      }
    }

    function draw() {
      if (state.scene === 0) drawMenu();
      else if (state.scene === 0.5) drawStartNightScreen();
      else if (state.scene === 1) drawGame();
      else if (state.scene === 1.5) drawBonusScreen();
      else if (state.scene === 2) drawBonus();
      else if (state.scene === 3) drawEnd();

      // Dibujar efecto fade si est√° activo
      drawFade();
    }

    function drawMenu() {
      ctx.fillStyle = C.bg;
      ctx.fillRect(0, 0, 240, 160);

      ctx.fillStyle = C.highlight;
      ctx.font = '16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('COVA SIMULATOR', 120, 30);

      drawSprite(120, 50, state.color, 1, 0, 1);

      ctx.fillStyle = C.text;
      ctx.font = '8px monospace';
      ctx.textAlign = 'left';
      ctx.fillStyle = '#00FF00';

      ctx.fillText('REGLAS', 10, 80);
      ctx.fillStyle = C.text;

      ctx.fillText('1. Bebe para gustar m√°s y ganar m√°s puntos por', 10, 90);
      ctx.fillText('cada conversaci√≥n', 10, 100);
      ctx.fillText('2. Es necesario beber al hablar con 3 chicas', 10, 110);
      ctx.fillText('3. Cova da Vella cierra a las 5am', 10, 120);
      ctx.fillText('4. Si bebes mucho se invertir√°n los controles', 10, 130);

      const blink = Math.floor(Date.now() / 500) % 2;
      if (blink) {
        ctx.fillStyle = C.highlight;
        ctx.textAlign = 'center';
        ctx.fillText('PRESS START', 120, 150);
      }
    }

    function drawGame() {
      state.tick++;

      // Fondo
      ctx.fillStyle = C.floor;
      ctx.fillRect(0, 0, 240, 160);

      // Offset de c√°mara
      const offsetY = 80 - state.camY;

      ctx.save();
      ctx.translate(0, offsetY);

      // Piso con patr√≥n
      for (let y = 0; y < WORLD_HEIGHT; y += 16) {
        for (let x = 0; x < 240; x += 16) {
          if ((x + y) % 32 === 0) {
            ctx.fillStyle = C.floor2;
            ctx.fillRect(x, y, 16, 16);
          }
        }
      }

      // Barra (arriba)
      ctx.fillStyle = C.bar;
      ctx.fillRect(40, state.barY - 10, 160, 20);
      ctx.fillStyle = C.bar2;
      ctx.fillRect(40, state.barY - 10, 160, 4);
      drawGirl(120, state.barY - 20, state.barmaidTimer, Math.floor(state.tick / 15) % 2, 0);

      // Obst√°culos (ralentizan)
      const obstacles = [
        { x: 20, y: 100, w: 16, h: 16 },
        { x: 204, y: 100, w: 16, h: 16 },
        { x: 60, y: 150, w: 16, h: 16 },
        { x: 164, y: 150, w: 16, h: 16 },
        { x: 100, y: 200, w: 16, h: 16 },
        { x: 124, y: 200, w: 16, h: 16 },
        { x: 40, y: 260, w: 16, h: 16 },
        { x: 184, y: 260, w: 16, h: 16 }
      ];

      // Obst√°culos (bumpers con cooldown)
      const nowTime = Date.now() / 1000;
      state.obstacles.forEach(obs => {
        const canBump = nowTime - obs.t > 20;

        if (!canBump) {
          // Obst√°culo en cooldown: transparencia y tiempo restante
          ctx.globalAlpha = 0.5;
          ctx.fillStyle = C.bar;
          ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
          ctx.globalAlpha = 1;

          // Mostrar tiempo restante
          ctx.fillStyle = C.red;
          ctx.font = '6px monospace';
          ctx.textAlign = 'center';
          const left = Math.ceil(20 - (nowTime - obs.t));
          ctx.fillText(left, obs.x + obs.w / 2, obs.y - 2);
        } else {
          // Obst√°culo disponible: color normal
          ctx.fillStyle = C.bar;
          ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
        }
      });

      // Pista de baile (abajo)
      ctx.fillStyle = C.green;
      ctx.globalAlpha = 0.3;
      ctx.fillRect(10, 360, 220, 120);
      ctx.globalAlpha = 1;

      // Chicas
      const now = Date.now() / 1000;
      state.girls.forEach(g => {
        const canTalk = now - g.t > 30;
        if (!canTalk) {
          ctx.globalAlpha = 0.5;
          drawGirl(g.x, g.y, g.c, Math.floor(state.tick / 15) % 2, g.spriteType);
          ctx.globalAlpha = 1;
          ctx.fillStyle = C.red;
          ctx.font = '6px monospace';
          ctx.textAlign = 'center';
          const left = Math.ceil(30 - (now - g.t));
          ctx.fillText(left, g.x, g.y - 10);
        } else {
          drawGirl(g.x, g.y, g.c, Math.floor(state.tick / 15) % 2, g.spriteType);
        }
      });

      // Jugador
      const pc = state.inverted ? darken(PC[state.color]) : PC[state.color];
      drawSprite(state.px, state.py, state.color, state.facing, Math.floor(state.tick / 10) % 2, 1);

      ctx.restore();

      // HUD (fijo)
      ctx.fillStyle = C.ui;
      ctx.fillRect(0, 0, 240, 20);
      ctx.strokeStyle = C.uiBorder;
      ctx.strokeRect(0, 0, 240, 20);

      ctx.fillStyle = C.text;
      ctx.font = '8px monospace';
      ctx.textAlign = 'left';
      const h = Math.floor(state.time / 60);
      const m = Math.floor(state.time % 60);
      // Icono reloj
      ctx.fillText('‚è∞', 5, 10);
      ctx.fillText(`${h}:${m < 10 ? '0' : ''}${m}`, 15, 10);

      // Icono cerveza
      ctx.fillText('üç∫', 40, 10);
      ctx.fillRect(50, 7, 60, 6);
      ctx.fillStyle = C.red;
      ctx.fillRect(51, 8, Math.min(58, state.drunk * 0.058), 4);

      ctx.fillStyle = C.text;
      ctx.fillText(`${state.score}`, 180, 10);

      // Joystick (esquina inferior derecha)
      ctx.fillStyle = 'rgba(32, 192, 208, 0.3)';
      ctx.beginPath();
      ctx.arc(215, 135, 20, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = C.uiBorder;
      ctx.lineWidth = 2;
      ctx.stroke();

      if (touch.joystick.active) {
        ctx.fillStyle = C.uiBorder;
        ctx.beginPath();
        ctx.arc(215 + touch.joystick.dx, 135 + touch.joystick.dy, 8, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.fillStyle = 'rgba(32, 192, 208, 0.6)';
        ctx.beginPath();
        ctx.arc(215, 135, 8, 0, Math.PI * 2);
        ctx.fill();
      }

      // Bot√≥n de acci√≥n (esquina inferior izquierda)
      ctx.fillStyle = touch.button.pressed ? 'rgba(248, 208, 72, 0.8)' : 'rgba(248, 208, 72, 0.4)';
      ctx.beginPath();
      ctx.arc(25, 135, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = C.highlight;
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = C.text;
      ctx.font = 'bold 12px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('A', 25, 140);

      // Di√°logo
      if (state.dTimer > 0) {
        ctx.fillStyle = C.ui;
        ctx.fillRect(10, 120, 220, 35);
        ctx.strokeStyle = C.uiBorder;
        ctx.lineWidth = 2;
        ctx.strokeRect(10, 120, 220, 35);
        ctx.fillStyle = C.text;
        ctx.font = '8px monospace';
        ctx.textAlign = 'left';
        wrapText(state.dialog, 15, 128, 210);
      } else {
        let msg = '';
        if (state.mustDrink) msg = 'Ve a la barra!';
        else if (state.mustTalk) msg = 'Habla con chicas!';
        else msg = 'Habla o ve a la barra';

        ctx.fillStyle = C.ui;
        ctx.fillRect(60, 145, 120, 12);
        ctx.strokeStyle = C.uiBorder;
        ctx.strokeRect(60, 145, 120, 12);
        ctx.fillStyle = C.highlight;
        ctx.font = '8px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(msg, 120, 153);
      }
    }

    function drawBonus() {
      ctx.fillStyle = C.bg;
      ctx.drawImage(spriteImages.portal, 0, 0, 240, 160);

      ctx.fillStyle = C.highlight;
      ctx.font = '12px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('FASE BONUS!', 120, 30);

      drawSprite(95, 105, state.color, 0, Math.floor(state.tick / 10) % 2, 2);

      ctx.fillStyle = C.floor;
      ctx.fillRect(20, 40, 200, 16);
      ctx.strokeStyle = C.uiBorder;
      ctx.strokeRect(20, 40, 200, 16);

      ctx.fillStyle = C.highlight;
      ctx.fillRect(state.bonus.target - 10, 41, 20, 14);

      ctx.fillStyle = PC[state.color];
      ctx.fillRect(state.bonus.x - 2, 38, 4, 20);

      ctx.fillStyle = C.text;
      ctx.font = '8px monospace';
      const tLeft = Math.max(0, state.bonus.max - state.bonus.t);
      ctx.fillText(`Mant√©n el equilibrio!`, 120, 70);
      //ctx.fillText(`Tiempo restante: ${tLeft}`, 120, 80);
      ctx.fillText(`Puntos: ${state.score}`, 60, 135);
      ctx.fillStyle = C.green;
      ctx.fillText(`Bonus: +${state.bonus.score}`, 180, 135);
      ctx.fillStyle = C.highlight;
      ctx.font = '12px monospace';
      ctx.fillText(`${state.score + state.bonus.score}`, 120, 150);

      // Botones t√°ctiles para la fase bonus
      // Bot√≥n izquierda (misma posici√≥n que bot√≥n de acci√≥n en el juego)
      ctx.fillStyle = touch.bonusLeft.pressed ? 'rgba(248, 208, 72, 0.8)' : 'rgba(248, 208, 72, 0.4)';
      ctx.beginPath();
      ctx.arc(25, 135, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = C.highlight;
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = C.text;
      ctx.font = 'bold 12px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('‚Üê', 25, 140);

      // Bot√≥n derecha (lado derecho, similar al joystick pero m√°s a la izquierda)
      ctx.fillStyle = touch.bonusRight.pressed ? 'rgba(248, 208, 72, 0.8)' : 'rgba(248, 208, 72, 0.4)';
      ctx.beginPath();
      ctx.arc(215, 135, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = C.highlight;
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = C.text;
      ctx.font = 'bold 12px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('‚Üí', 215, 140);
    }

    function drawEnd() {
      ctx.fillStyle = C.bg;
      ctx.fillRect(0, 0, 240, 160);

      ctx.fillStyle = C.highlight;
      ctx.font = '14px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('FIN', 120, 30);

      ctx.fillStyle = C.ui;
      ctx.fillRect(40, 50, 160, 60);
      ctx.strokeStyle = C.uiBorder;
      ctx.strokeRect(40, 50, 160, 60);

      ctx.fillStyle = C.text;
      ctx.font = '8px monospace';
      ctx.fillText(`Puntuaci√≥n: ${state.score}`, 120, 70);
      ctx.fillStyle = C.green;
      ctx.fillText(`Bonus: ${state.bonus.score}`, 120, 85);
      ctx.fillStyle = C.highlight;
      ctx.font = '16px monospace';
      ctx.fillText(`${state.score + state.bonus.score}`, 120, 105);

      const blink = Math.floor(Date.now() / 500) % 2;
      if (blink) {
        ctx.fillStyle = C.text;
        ctx.font = '8px monospace';
        ctx.fillText('PRESS START', 120, 145);
      }
    }

    // Funciones para dibujar pantallas intermedias
    function drawStartNightScreen() {
      // Fondo oscuro
      ctx.fillStyle = C.bg;
      ctx.fillRect(0, 0, 240, 160);

      // Marco decorativo
      ctx.fillStyle = C.ui;
      ctx.fillRect(20, 20, 200, 120);
      ctx.strokeStyle = C.uiBorder;
      ctx.lineWidth = 2;
      ctx.strokeRect(20, 20, 200, 120);

      // T√≠tulo principal
      ctx.fillStyle = C.highlight;
      ctx.font = '16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('COMIENZA LA NOCHE', 120, 45);

      // Emoji de luna (simulado con texto)
      ctx.fillStyle = C.text;
      ctx.font = '20px monospace';
      ctx.fillText('‚óê', 120, 70);

      // Texto descriptivo
      ctx.fillStyle = C.text;
      ctx.font = '8px monospace';
      ctx.fillText('Es hora de salir de', 120, 90);
      ctx.fillText('fiesta por Cova da Vella', 120, 100);

      // Bot√≥n animado
      const buttonBlink = Math.floor(Date.now() / 800) % 2;
      if (buttonBlink) {
        ctx.fillStyle = C.green;
        ctx.fillRect(70, 110, 100, 20);
        ctx.strokeStyle = C.text;
        ctx.strokeRect(70, 110, 100, 20);

        ctx.fillStyle = C.bg;
        ctx.font = '8px monospace';
        ctx.fillText('EMPEZAR', 120, 123);
      } else {
        ctx.strokeStyle = C.green;
        ctx.strokeRect(70, 110, 100, 20);

        ctx.fillStyle = C.green;
        ctx.font = '8px monospace';
        ctx.fillText('EMPEZAR', 120, 123);
      }
    }

    function drawBonusScreen() {
      // Fondo oscuro
      ctx.fillStyle = C.bg;
      ctx.fillRect(0, 0, 240, 160);

      // Marco decorativo m√°s elegante
      ctx.fillStyle = C.ui;
      ctx.fillRect(15, 15, 210, 130);
      ctx.strokeStyle = C.highlight;
      ctx.lineWidth = 2;
      ctx.strokeRect(15, 15, 210, 130);

      // T√≠tulo celebratorio
      ctx.fillStyle = C.highlight;
      ctx.font = '14px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('Fin de la noche!', 120, 35);
      ctx.font = '16px monospace';
      // ctx.fillText('', 120, 55);

      // Texto descriptivo
      ctx.fillStyle = C.text;
      ctx.font = '8px monospace';
      ctx.fillText('Tras una larga noche', 120, 70);
      ctx.fillText('el taxi te ha dejado', 120, 80);
      ctx.fillText('de vuelta al barrio', 120, 90);

      // Puntuaci√≥n obtenida
      ctx.fillStyle = C.green;
      ctx.font = '10px monospace';
      ctx.fillText(`PUNTUACION: ${state.finalScore}`, 120, 115);

      // Bot√≥n animado
      const buttonBlink = Math.floor(Date.now() / 600) % 2;
      if (buttonBlink) {
        ctx.fillStyle = C.highlight;
        ctx.fillRect(60, 125, 120, 18);
        ctx.strokeStyle = C.text;
        ctx.strokeRect(60, 125, 120, 18);

        ctx.fillStyle = C.bg;
        ctx.font = '8px monospace';
        ctx.fillText('CONTINUAR', 120, 137);
      } else {
        ctx.strokeStyle = C.highlight;
        ctx.strokeRect(60, 125, 120, 18);

        ctx.fillStyle = C.highlight;
        ctx.font = '8px monospace';
        ctx.fillText('CONTINUAR', 120, 137);
      }
    }

    // Cargar im√°genes de sprites
    const spriteImages = {};
    function loadSpriteImages() {
      // Sprites para caminar hacia los lados
      spriteImages.side0 = new Image();
      spriteImages.side0.src = 'assets/character-side-0.png';

      spriteImages.side1 = new Image();
      spriteImages.side1.src = 'assets/character-side-1.png';

      // Sprites para caminar hacia arriba
      spriteImages.walking0 = new Image();
      spriteImages.walking0.src = 'assets/character-walking-0.png';

      spriteImages.walking1 = new Image();
      spriteImages.walking1.src = 'assets/character-walking-1.png';

      // Sprites para caminar hacia abajo
      spriteImages.back0 = new Image();
      spriteImages.back0.src = 'assets/character-back-0.png';

      spriteImages.back1 = new Image();
      spriteImages.back1.src = 'assets/character-back-1.png';

      // Sprites para las chicas
      spriteImages.girl0_0 = new Image();
      spriteImages.girl0_0.src = 'assets/girl0-0.png';

      spriteImages.girl0_1 = new Image();
      spriteImages.girl0_1.src = 'assets/girl0-1.png';

      spriteImages.girl1_0 = new Image();
      spriteImages.girl1_0.src = 'assets/girl1-0.png';

      spriteImages.girl1_1 = new Image();
      spriteImages.girl1_1.src = 'assets/girl1-1.png';

      spriteImages.portal = new Image();
      spriteImages.portal.src = 'assets/portal.png';

    }
    // Llamar a la funci√≥n de carga cuando se inicie el script
    loadSpriteImages();

    function drawSprite(x, y, color, dir, frame, scale) {
      let img;

      // Solo animar si el jugador se est√° moviendo
      const animFrame = state.isMoving ? frame : 0;

      // Aplicar transparencia si los controles est√°n invertidos
      if (state.inverted) {
        ctx.globalAlpha = 0.5;
      } else {
        ctx.globalAlpha = 1;
      }

      // Seleccionar sprite seg√∫n la direcci√≥n
      if (dir === 2 || dir === 3) {
        // Movimiento lateral (izquierda/derecha) - usar sprites side
        img = animFrame === 0 ? spriteImages.side0 : spriteImages.side1;
      } else if ((dir === 1 && !state.inverted) || (dir === 0 && state.inverted)) {
        // Movimiento vertical (arriba/abajo) - usar sprites walking
        img = animFrame === 0 ? spriteImages.walking0 : spriteImages.walking1;
      } else {
        img = animFrame === 0 ? spriteImages.back0 : spriteImages.back1;
      }

      // Verificar que la imagen est√© cargada
      if (img && img.complete && img.naturalHeight !== 0) {
        ctx.save();

        // Voltear horizontalmente si va hacia la izquierda
        if ((dir !== 2 && !state.inverted) || (dir === 2 && state.inverted)) {
          ctx.scale(-1, 1);
          ctx.drawImage(img, -x - 8, y - 8, 16 * scale, 16 * scale);
        } else {
          ctx.drawImage(img, x - 8, y - 8, 16 * scale, 16 * scale);
        }

        ctx.restore();
      }

      // Restaurar transparencia normal
      ctx.globalAlpha = 1;
    }

    function drawGirl(x, y, idx, frame, spriteType) {
      let img;

      // Seleccionar el sprite seg√∫n el tipo y frame
      if (spriteType === 0) {
        img = frame === 0 ? spriteImages.girl0_0 : spriteImages.girl0_1;
      } else {
        img = frame === 0 ? spriteImages.girl1_0 : spriteImages.girl1_1;
      }

      // Verificar que la imagen est√© cargada
      if (img && img.complete && img.naturalHeight !== 0) {
        // Dibujar la imagen centrada en las coordenadas x, y
        const width = 16; // Ancho del sprite
        const height = 16; // Alto del sprite
        ctx.drawImage(img, x - width / 2, y - height / 2, width, height);
      }
    }

    function darken(hex) {
      const r = Math.max(0, parseInt(hex.slice(1, 3), 16) - 40);
      const g = Math.max(0, parseInt(hex.slice(3, 5), 16) - 40);
      const b = Math.max(0, parseInt(hex.slice(5, 7), 16) - 40);
      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    function wrapText(text, x, y, maxW) {
      const words = text.split(' ');
      let line = '';
      let py = y;
      for (const word of words) {
        const test = line + word + ' ';
        if (ctx.measureText(test).width > maxW && line) {
          ctx.fillText(line, x, py);
          line = word + ' ';
          py += 8;
        } else {
          line = test;
        }
      }
      ctx.fillText(line, x, py);
    }

    function update(dt) {
      // Actualizar transiciones fade
      updateFade(dt);

      if (state.scene === 1) updateGame(dt);
      else if (state.scene === 2) updateBonus(dt);
    }

    function updateGame(dt) {
      state.time += dt * 3;

      if (state.drunk > 0) state.drunk -= dt * 5;

      if (state.time >= 1440) state.time %= 1440;
      if (state.time >= 300 && state.time < 720 && !state.transitioning) {
        // Ir a pantalla intermedia del bonus en lugar de directamente al bonus
        startFadeOut(1.5);
        state.bonus.max = Math.min(30, state.score / 100);
        state.bonus.t = 0;
        state.bonus.score = 0;
        return;
      }

      // Inversi√≥n
      if (state.drunk >= 800) {
        state.inverted = Math.floor(Date.now() / 5000) % 2 === 0;
      } else if (state.drunk >= 500) {
        state.inverted = true;
      } else {
        state.inverted = false;
      }

      // Movimiento
      let dx = 0, dy = 0;

      // Teclado
      if (keys.ArrowUp) { dy = -2; state.facing = 0; }
      if (keys.ArrowDown) { dy = 2; state.facing = 1; }
      if (keys.ArrowLeft) { dx = -2; state.facing = 2; }
      if (keys.ArrowRight) { dx = 2; state.facing = 3; }

      // Joystick t√°ctil
      if (touch.joystick.active) {
        dx += touch.joystick.dx * 0.15;
        dy += touch.joystick.dy * 0.15;

        // Determinar direcci√≥n seg√∫n joystick
        if (Math.abs(touch.joystick.dx) > Math.abs(touch.joystick.dy)) {
          state.facing = touch.joystick.dx > 0 ? 3 : 2;
        } else if (Math.abs(touch.joystick.dy) > 0) {
          state.facing = touch.joystick.dy > 0 ? 1 : 0;
        }
      }

      if (state.inverted) { dx = -dx; dy = -dy; }

      // Detectar si el jugador se est√° moviendo
      state.isMoving = Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1;

      if (state.drunk > 0) {
        dx += (Math.random() - 0.5) * state.drunk * 0.014;
      }

      // Verificar colisi√≥n con obst√°culos (efecto bumper)
      const obstacles = state.obstacles;

      // Verificar colisi√≥n individual con cada obst√°culo
      const now = Date.now() / 1000;
      let onCooldownObstacle = false;

      obstacles.forEach(obs => {
        // Verificar si el obst√°culo est√° en cooldown
        const canBump = now - obs.t > 20;

        // Calcular posici√≥n del jugador despu√©s del movimiento
        const newPx = state.px + dx;
        const newPy = state.py + dy;

        // Verificar si hay colisi√≥n
        if (newPx + 4 > obs.x && newPx - 4 < obs.x + obs.w &&
          newPy + 8 > obs.y && newPy - 8 < obs.y + obs.h) {

          if (canBump) {
            // Obst√°culo disponible: efecto bumper
            // Activar cooldown del obst√°culo
            obs.t = now;

            state.score -= 50 - Math.floor(state.drunk * 0.1);

            // Calcular el centro del obst√°culo
            const obsCenterX = obs.x + obs.w / 2;
            const obsCenterY = obs.y + obs.h / 2;

            // Calcular la direcci√≥n del empuje (desde el centro del obst√°culo hacia el jugador)
            const pushX = state.px - obsCenterX;
            const pushY = state.py - obsCenterY;
            document.getElementById('collision').pause();
            document.getElementById('collision').currentTime = 0;
            document.getElementById('collision').volume = 0.4;
            document.getElementById('collision').play();

            // Normalizar la direcci√≥n y aplicar fuerza de rebote
            const distance = Math.sqrt(pushX * pushX + pushY * pushY);
            if (distance > 0) {
              const bumperForce = 36; // Fuerza del empuje aumentada
              dx += (pushX / distance) * bumperForce;
              dy += (pushY / distance) * bumperForce;
            }
          } else {
            // Obst√°culo en cooldown: ralentizar 75%
            onCooldownObstacle = true;
          }
        }
      });

      // Aplicar ralentizaci√≥n si est√° pasando por obst√°culo en cooldown
      if (onCooldownObstacle) {
        dx *= 0.25; // Reducir velocidad al 25% (ralentizaci√≥n del 75%)
        dy *= 0.25;
      }

      state.px = Math.max(10, Math.min(230, state.px + dx));
      state.py = Math.max(20, Math.min(WORLD_HEIGHT - 10, state.py + dy));

      // C√°mara sigue al jugador
      state.camY = state.py;

      // Interacci√≥n barra
      const distBar = Math.sqrt((state.px - 120) ** 2 + (state.py - state.barY) ** 2);
      if (distBar < 16 && state.spacePressed && !state.mustTalk) {
        drink();
        state.spacePressed = false;
      }

      // Interacci√≥n chicas
      if (!state.mustDrink) {
        const now = Date.now() / 1000;
        if (now - state.lastTalk > 1) {
          state.girls.forEach(g => {
            const d = Math.sqrt((state.px - g.x) ** 2 + (state.py - g.y) ** 2);
            const canTalk = now - g.t > 30;
            if (d < 15 && state.spacePressed && canTalk) {
              talkGirl(g, now);
              state.lastTalk = now;
              state.spacePressed = false;
            }
          });
        }
      }

      if (state.dTimer > 0) state.dTimer -= dt;
    }

    function drink() {
      state.drunk += 120;

      if (state.drunk > 1000) state.drunk = 1000;

      state.girlCount = 0;
      state.mustDrink = false;
      state.mustTalk = true;

      document.getElementById('drink').volume = 0.6;
      document.getElementById('drink').play();
      const msgs = state.drunk < 700 ?
        ['Aqu√≠ tienes tu licorca, gracias.', 'Una cerveza marchando. Son 2,5‚Ç¨', 'Una Estrella? Claro, sin problema. Efectivo o tarjeta?'] :
        ['Cuando acabe mi turno de noche ll√°mame! Si no estoy con mi madre de recados estar√© libre!', 'Eres el mejor cliente que tiene el bar, ojal√° pudi√©semos hablar m√°s!', 'Se que soy algo mayor para ti pero... como me gustar√≠a que me cuidases!'];
      state.dialog = msgs[Math.floor(Math.random() * msgs.length)];
      state.dTimer = 2; // Cambiado de 999 a 2
    }

    function talkGirl(girl, now) {
      girl.t = now;
      state.girlCount++;

      document.getElementById('talk').pause();
      document.getElementById('talk').volume = 0.65;
      document.getElementById('talk').currentTime = 0;
      document.getElementById('talk').play();

      const msgs = state.drunk < 400 ?
        ['Qu√© t√≠o tan raro... d√©jame en paz.', 'No me interesas...', 'No se qui√©n eres, vete por favor.'] : state.drunk < 700 ?
          ['Si, la verdad es que estamos estudiando en la USC tambi√©n.', 'Estamos esperando por unas amigas de Erasmus que vienen de Portugal. En un rato llegan...', 'Fuimos a Tarasca el otro d√≠a y nos robaron el paraguas. Qu√© mala suerte...'] :
          ['Qu√© divertido eres! Te puedo pintar un coraz√≥n en la frente?', 'Qu√© chico tan interesante! Se nota que te preocupas por las mujeres, eres un encanto!', 'Vamos a bailar juntos! Eres genial!'];
      state.dialog = msgs[Math.floor(Math.random() * msgs.length)];
      state.dTimer = 2;

      state.score += Math.floor(50 * (1 + state.drunk * 0.005));

      if (state.girlCount >= 3) {
        state.mustDrink = true;
        state.mustTalk = false;
      } else {
        state.mustTalk = false;
      }
    }

    function updateBonus(dt) {
      state.tick++;
      state.isMoving = true;
      state.bonus.t += dt;

      if (state.bonus.t >= state.bonus.max) {
        state.scene = 3;
        state.time = Date.now();
        return;
      }

      const speed = 1 + Math.sin(state.bonus.t * 0.8) * 0.5;
      state.bonus.target += Math.sin(state.bonus.t * 2.5) * 2 * speed;
      state.bonus.target = Math.max(30, Math.min(210, state.bonus.target));

      // Controles de teclado
      if (keys.ArrowLeft) state.bonus.x -= 3;
      if (keys.ArrowRight) state.bonus.x += 3;

      // Controles t√°ctiles
      if (touch.bonusLeft.pressed) state.bonus.x -= 3;
      if (touch.bonusRight.pressed) state.bonus.x += 3;

      state.bonus.x = Math.max(22, Math.min(218, state.bonus.x));

      if (Math.abs(state.bonus.x - state.bonus.target) < 12) {
        state.bonus.score += Math.round(100 * dt);
      }
    }

    let last = 0;
    function loop(t) {
      const dt = Math.min((t - last) / 1000, 0.1);
      last = t;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>

</html>
